package sort;public class SortingExample1 {    public static void main(String[] args){    }    /**     *The selection sort algorithm sorts an array by repeatedly finding the minimum element     * (considering ascending order) from unsorted part and putting it at the beginning.     * The algorithm maintains two subarrays in a given array.     */    private void selectionShort(int[] arr){        int n = arr.length;        // One by one move boundary of unsorted subarray        for (int i = 0; i < n-1; i++)        {            // Find the minimum element in unsorted array            int min_idx = i;            for (int j = i+1; j < n; j++)                if (arr[j] < arr[min_idx])                    min_idx = j;            // Swap the found minimum element with the first            // element            int temp = arr[min_idx];            arr[min_idx] = arr[i];            arr[i] = temp;        }    }    /**     * Bubble Sort is the simplest sorting algorithm that works by repeatedly swapping     * the adjacent elements if they are in wrong order.     * @param arr     */    private void bubbleSort(int[] arr){        int size = arr.length;        int temp;        for(int i = 0; i< size - 1; i++){            for(int j = 0; j< size - i-  1; j++){                if(arr[j] > arr[j+1]){                    temp = arr[j];                    arr[j]  = arr[j+1];                    arr[j+1] = temp;                }            }        }    }    /**     *Insertion sort     * Insertion sort is a simple sorting algorithm that works similar to the way you sort playing cards in your hands.     * The array is virtually split into a sorted and an unsorted part. Values from the unsorted part are picked and placed at the correct position in the sorted part.     * Algorithm     * To sort an array of size n in ascending order:     * 1: Iterate from arr[1] to arr[n] over the array.     * 2: Compare the current element (key) to its predecessor.     * 3: If the key element is smaller than its predecessor, compare it to the elements before. Move the greater elements one position up to make space for the swapped element.     */    private void insertionSort(int[] arr){            int n = arr.length;            for (int i = 1; i < n; ++i) {                int key = arr[i];                int j = i - 1;            /* Move elements of arr[0..i-1], that are               greater than key, to one position ahead               of their current position */                while (j >= 0 && arr[j] > key) {                    arr[j + 1] = arr[j];                    j = j - 1;                }                arr[j + 1] = key;            }    }    // Merges two subarrays of arr[].    // First subarray is arr[l..m]    // Second subarray is arr[m+1..r]    void merge(int arr[], int l, int m, int r)    {        // Find sizes of two subarrays to be merged        int n1 = m - l + 1;        int n2 = r - m;        /* Create temp arrays */        int L[] = new int[n1];        int R[] = new int[n2];        /*Copy data to temp arrays*/        for (int i = 0; i < n1; ++i)            L[i] = arr[l + i];        for (int j = 0; j < n2; ++j)            R[j] = arr[m + 1 + j];        /* Merge the temp arrays */        // Initial indexes of first and second subarrays        int i = 0, j = 0;        // Initial index of merged subarry array        int k = l;        while (i < n1 && j < n2) {            if (L[i] <= R[j]) {                arr[k] = L[i];                i++;            }            else {                arr[k] = R[j];                j++;            }            k++;        }        /* Copy remaining elements of L[] if any */        while (i < n1) {            arr[k] = L[i];            i++;            k++;        }        /* Copy remaining elements of R[] if any */        while (j < n2) {            arr[k] = R[j];            j++;            k++;        }    }    // Main function that sorts arr[l..r] using    // merge()    void sort(int arr[], int l, int r)    {        if (l < r) {            // Find the middle point            int m =l+ (r-l)/2;            // Sort first and second halves            sort(arr, l, m);            sort(arr, m + 1, r);            // Merge the sorted halves            merge(arr, l, m, r);        }    }    /**     * Quick sort     * Like Merge Sort, QuickSort is a Divide and Conquer algorithm.     * It picks an element as pivot and partitions the given array around the picked pivot.     * There are many different versions of quickSort that pick pivot in different ways.     *     * Always pick first element as pivot.     * Always pick last element as pivot (implemented below)     * Pick a random element as pivot.     * Pick median as pivot.     */    private void printArray(int[] arr){        for (int j : arr) {            System.out.print(j);        }    }}