package threadConcept;/** * yield(): Suppose there are three threads t1, t2, and t3. * Thread t1 gets the processor and starts its execution and * thread t2 and t3 are in Ready/Runnable state. * Completion time for thread t1 is 5 hour and completion time for t2 is 5 minutes. * Since t1 will complete its execution after 5 hours, t2 has to wait for 5 hours to just finish 5 minutes job. * In such scenarios where one thread is taking too much time to complete its execution, * we need a way to prevent execution of a thread in between if something important is pending. yield() helps us in doing so. * * yield() basically means that the thread is not doing anything particularly important and if any other threads or processes need to be run, they should run. Otherwise, the current thread will continue to run. */public class ThreadYieldExample {    public static void main(String...args){        ThreadYield1 t1 = new ThreadYield1();        ThreadYield2 t2 = new ThreadYield2();        t1.setName("Yield Thread");        t2.setName("Other Thread");        t1.start();        t2.start();    }}class ThreadYield1 extends  Thread{    @Override    public void run() {        for (int i = 0;i<5;i++){            try {                Thread.sleep(1000);            } catch (InterruptedException e) {                e.printStackTrace();            }            System.out.println(this.getName()+" Is Running "+i);        }        yield();    }}class ThreadYield2 extends  Thread{    @Override    public void run() {        for (int i = 0;i<5;i++){            System.out.println(this.getName()+" Is Running "+i);        }    }}